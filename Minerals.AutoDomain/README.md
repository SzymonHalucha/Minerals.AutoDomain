# Minerals.AutoDomain

![GitHub License](https://img.shields.io/github/license/SzymonHalucha/Minerals.AutoDomain?style=for-the-badge)
![NuGet Version](https://img.shields.io/nuget/v/Minerals.AutoDomain?style=for-the-badge)
![NuGet Downloads](https://img.shields.io/nuget/dt/Minerals.AutoDomain?style=for-the-badge)

[Package on nuget.org](https://www.nuget.org/packages/Minerals.AutoDomain/)

*WORK IN PROGRESS...*

This package, with the help of an incremental source generator, provides a fast method of defining domain layer components with their specific implementation, such as aggregates, entities and domain events.

## Features

- **Reduced boilerplate:** Spend less time writing boilerplate code and more time crafting the business logic of your application.
- **Strongly typed identifier:** Package has integrated automatic generation of strongly typed identifiers for every entity and aggregate.
- **Domain events:** Package gives you the ability to customize arguments for automatically generated domain events.
- **Compatible with .NET Standard 2.0 and C# 7.3+:** Works on a wide range of platforms and development environments.

## Installation

Add the Minerals.AutoDomain nuget package to your C# project using the following methods:

### 1. Project file definition

```xml
<PackageReference Include="Minerals.AutoDomain" Version="0.3.0" />
```

### 2. dotnet command

```bat
dotnet add package Minerals.AutoDomain
```

## Usage

Package is used by adding the selected attribute to the suitable object.

### Entity

Sample code fragment that is needed to generate Entity, please notice that the class that implements the Entity attribute for correct functioning should have a ``partial`` modifier.

```csharp
// ...
[Minerals.AutoDomain.Entity]
public partial class ExampleEntity
{
    // Your code here...
}
// ...
```

The code above will generate a two files with the following code:

```csharp
// <auto-generated>
// This code was generated by a tool.
// Name: Minerals.AutoDomain.Generators
// Version: {Version}
// </auto-generated>
[global::System.Diagnostics.DebuggerNonUserCode]
[global::System.Runtime.CompilerServices.CompilerGenerated]
[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
public partial class ExampleEntity : global::Minerals.AutoDomain.IEntity, global::System.IEquatable<ExampleEntity>
{
    public ExampleEntityId Id { get; private set; }

    public bool Equals(ExampleEntity other)
    {
        return other.Id.Value.Equals(Id.Value);
    }

    public override bool Equals(object obj)
    {
        return obj is ExampleEntity other && other.Id.Value.Equals(Id.Value);
    }

    public override int GetHashCode()
    {
        return Id.Value.GetHashCode();
    }

    public static bool operator ==(ExampleEntity left, ExampleEntity right)
    {
        return left != null && right != null && left.Id.Value.Equals(right.Id.Value);
    }

    public static bool operator !=(ExampleEntity left, ExampleEntity right)
    {
        return (left != null && right == null) || (left == null && right != null) || !left.Id.Value.Equals(right.Id.Value);
    }
}

// And

// <auto-generated>
// This code was generated by a tool.
// Name: Minerals.AutoDomain.Generators
// Version: {Version}
// </auto-generated>
[global::System.Diagnostics.DebuggerNonUserCode]
[global::System.Runtime.CompilerServices.CompilerGenerated]
[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
public readonly struct ExampleEntityId : global::System.IEquatable<ExampleEntityId>
{
    public int Value => _value;

    private readonly int _value;

    public ExampleEntityId(int value)
    {
        _value = value;
    }

    public bool Equals(ExampleEntityId other)
    {
        return other.Value.Equals(Value);
    }

    public override bool Equals(object obj)
    {
        return obj is ExampleEntityId other && other.Value.Equals(Value);
    }

    public override int GetHashCode()
    {
        return Value.GetHashCode();
    }

    public static bool operator ==(ExampleEntityId left, ExampleEntityId right)
    {
        return left.Value.Equals(right.Value);
    }

    public static bool operator !=(ExampleEntityId left, ExampleEntityId right)
    {
        return !left.Value.Equals(right.Value);
    }
}
```

### AggregateRoot

Sample code fragment that is needed to generate AggregateRoot, please notice that the class that implements the AggregateRoot attribute for correct functioning should have a ``partial`` modifier.

```csharp
// ...
[Minerals.AutoDomain.AggregateRoot]
public partial class ExampleAggregateRoot
{
    // Your code here...
}
// ...
```

The code above will generate a two files with the following code:

```csharp
// <auto-generated>
// This code was generated by a tool.
// Name: Minerals.AutoDomain.Generators
// Version: {Version}
// </auto-generated>
[global::System.Diagnostics.DebuggerNonUserCode]
[global::System.Runtime.CompilerServices.CompilerGenerated]
[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
public partial class ExampleAggregate : global::Minerals.AutoDomain.IAggregateRoot, global::System.IEquatable<ExampleAggregate>
{
    public ExampleAggregateId Id { get; private set; }

    public global::System.Collections.Generic.IReadOnlyCollection<global::Minerals.AutoDomain.IDomainEvent> DomainEvents => _domainEvents.AsReadOnly();

    private readonly global::System.Collections.Generic.List<global::Minerals.AutoDomain.IDomainEvent> _domainEvents = new global::System.Collections.Generic.List<global::Minerals.AutoDomain.IDomainEvent>();

    public void AppendDomainEvent(global::Minerals.AutoDomain.IDomainEvent domainEvent)
    {
        _domainEvents.Add(domainEvent);
    }

    public void ClearDomainEvents()
    {
        _domainEvents.Clear();
    }

    public bool Equals(ExampleAggregate other)
    {
        return other.Id.Value.Equals(Id.Value);
    }

    public override bool Equals(object obj)
    {
        return obj is ExampleAggregate other && other.Id.Value.Equals(Id.Value);
    }

    public override int GetHashCode()
    {
        return Id.Value.GetHashCode();
    }

    public static bool operator ==(ExampleAggregate left, ExampleAggregate right)
    {
        return left != null && right != null && left.Id.Value.Equals(right.Id.Value);
    }

    public static bool operator !=(ExampleAggregate left, ExampleAggregate right)
    {
        return (left != null && right == null) || (left == null && right != null) || !left.Id.Value.Equals(right.Id.Value);
    }
}

// And

// <auto-generated>
// This code was generated by a tool.
// Name: Minerals.AutoDomain.Generators
// Version: {Version}
// </auto-generated>
[global::System.Diagnostics.DebuggerNonUserCode]
[global::System.Runtime.CompilerServices.CompilerGenerated]
[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
public readonly struct ExampleAggregateId : global::System.IEquatable<ExampleAggregateId>
{
    public int Value => _value;

    private readonly int _value;

    public ExampleAggregateId(int value)
    {
        _value = value;
    }

    public bool Equals(ExampleAggregateId other)
    {
        return other.Value.Equals(Value);
    }

    public override bool Equals(object obj)
    {
        return obj is ExampleAggregateId other && other.Value.Equals(Value);
    }

    public override int GetHashCode()
    {
        return Value.GetHashCode();
    }

    public static bool operator ==(ExampleAggregateId left, ExampleAggregateId right)
    {
        return left.Value.Equals(right.Value);
    }

    public static bool operator !=(ExampleAggregateId left, ExampleAggregateId right)
    {
        return !left.Value.Equals(right.Value);
    }
}
```

### Domain Events

The code below will generate a partial struct with comparison methods.

```csharp
[Minerals.AutoDomain.DomainEvent]
public readonly partial struct ExampleDomainEvent
{
    public string Property1 { get; }
    public readonly int Field1;
}
```

The code fragment shown above will generate the following domain events code, please notice that the generated events are in the ``Events`` sub-namespace.

```csharp
// <auto-generated>
// This code was generated by a tool.
// Name: Minerals.AutoDomain.Generators
// Version: {Version}
// </auto-generated>
[global::System.Diagnostics.DebuggerNonUserCode]
[global::System.Runtime.CompilerServices.CompilerGenerated]
[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
public readonly partial struct ExampleDomainEvent : global::Minerals.AutoDomain.IDomainEvent, global::System.IEquatable<ExampleDomainEvent>
{
    public bool Equals(ExampleDomainEvent other)
    {
        return other.Field1.Equals(Field1) && other.Property1.Equals(Property1);
    }

    public override bool Equals(object obj)
    {
        return obj is ExampleDomainEvent other && other.Field1.Equals(Field1) && other.Property1.Equals(Property1);
    }

    public override int GetHashCode()
    {
        return global::System.HashCode.Combine(Field1, Property1);
    }

    public static bool operator ==(ExampleDomainEvent left, ExampleDomainEvent right)
    {
        return left.Field1.Equals(right.Field1) && left.Property1.Equals(right.Property1);
    }

    public static bool operator !=(ExampleDomainEvent left, ExampleDomainEvent right)
    {
        return !left.Field1.Equals(right.Field1) || !left.Property1.Equals(right.Property1);
    }
}
```

### Generate Domain Events

The code shown below will generate three domain events. The GenerateDomainEvent attribute can be used on classes, structures, records, methods, constructors and properties. The GenerateDomainEvent attribute will inherit arguments from objects or members that will be implementing it.

```csharp
using Minerals.AutoDomain;

namespace ExampleNamespace
{
    [AggregateRoot, GenerateDomainEvent("ExampleClassUpdatedDomainEvent")]
    public partial class ExampleClass
    {
        [GenerateDomainEvent("ExampleClassCreatedDomainEvent")]
        public ExampleClass(int exampleNumber, string exampleText)
        {
            // ...
            AppendDomainEvent(new ExampleClassCreatedDomainEvent(Id, exampleNumber, exampleText));
        }

        // First argument: Name of the domain event
        // Second argument: Should the domain event have the parent identifier as an argument
        [GenerateDomainEvent("WorkDoneDomainEvent", false)]
        public void DoWork(int arg1, int arg2, int arg3)
        {
            // ...
            AppendDomainEvent(new WorkDoneDomainEvent(arg1, arg2, arg3));
        }
    }
}
```

The code fragment shown above will generate the following domain events code, please notice that the generated events are in the ``Events`` sub-namespace.

```csharp
// <auto-generated>
// This code was generated by a tool.
// Name: Minerals.AutoDomain.Generators
// Version: {Version}
// </auto-generated>
namespace ExampleNamespace.Events
{
    [global::System.Diagnostics.DebuggerNonUserCode]
    [global::System.Runtime.CompilerServices.CompilerGenerated]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public readonly partial struct ExampleClassUpdatedDomainEvent : global::Minerals.AutoDomain.IDomainEvent, global::System.IEquatable<ExampleClassUpdatedDomainEvent>
    {
        public ExampleClassId ExampleClassId { get; }

        public ExampleClassUpdatedDomainEvent(ExampleClassId exampleClassId)
        {
            ExampleClassId = exampleClassId;
        }

        public bool Equals(ExampleClassUpdatedDomainEvent other)
        {
            return other.ExampleClassId.Equals(ExampleClassId);
        }

        public override bool Equals(object obj)
        {
            return obj is ExampleClassUpdatedDomainEvent other && other.ExampleClassId.Equals(ExampleClassId);
        }

        public override int GetHashCode()
        {
            return global::System.HashCode.Combine(ExampleClassId);
        }

        public static bool operator ==(ExampleClassUpdatedDomainEvent left, ExampleClassUpdatedDomainEvent right)
        {
            return left.ExampleClassId.Equals(right.ExampleClassId);
        }

        public static bool operator !=(ExampleClassUpdatedDomainEvent left, ExampleClassUpdatedDomainEvent right)
        {
            return !left.ExampleClassId.Equals(right.ExampleClassId);
        }
    }
}

// And

// <auto-generated>
// This code was generated by a tool.
// Name: Minerals.AutoDomain.Generators
// Version: {Version}
// </auto-generated>
namespace ExampleNamespace.Events
{
    [global::System.Diagnostics.DebuggerNonUserCode]
    [global::System.Runtime.CompilerServices.CompilerGenerated]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public readonly partial struct ExampleClassCreatedDomainEvent : global::Minerals.AutoDomain.IDomainEvent, global::System.IEquatable<ExampleClassCreatedDomainEvent>
    {
        public ExampleClassId ExampleClassId { get; }
        public int ExampleNumber { get; }
        public string ExampleText { get; }

        public ExampleClassCreatedDomainEvent(ExampleClassId exampleClassId, int exampleNumber, string exampleText)
        {
            ExampleClassId = exampleClassId;
            ExampleNumber = exampleNumber;
            ExampleText = exampleText;
        }

        public bool Equals(ExampleClassCreatedDomainEvent other)
        {
            return other.ExampleClassId.Equals(ExampleClassId) && other.ExampleNumber.Equals(ExampleNumber) && other.ExampleText.Equals(ExampleText);
        }

        public override bool Equals(object obj)
        {
            return obj is ExampleClassCreatedDomainEvent other && other.ExampleClassId.Equals(ExampleClassId) && other.ExampleNumber.Equals(ExampleNumber) && other.ExampleText.Equals(ExampleText);
        }

        public override int GetHashCode()
        {
            return global::System.HashCode.Combine(ExampleClassId, ExampleNumber, ExampleText);
        }

        public static bool operator ==(ExampleClassCreatedDomainEvent left, ExampleClassCreatedDomainEvent right)
        {
            return left.ExampleClassId.Equals(right.ExampleClassId) && left.ExampleNumber.Equals(right.ExampleNumber) && left.ExampleText.Equals(right.ExampleText);
        }

        public static bool operator !=(ExampleClassCreatedDomainEvent left, ExampleClassCreatedDomainEvent right)
        {
            return !left.ExampleClassId.Equals(right.ExampleClassId) || !left.ExampleNumber.Equals(right.ExampleNumber) || !left.ExampleText.Equals(right.ExampleText);
        }
    }
}

// And

// <auto-generated>
// This code was generated by a tool.
// Name: Minerals.AutoDomain.Generators
// Version: {Version}
// </auto-generated>
namespace ExampleNamespace.Events
{
    [global::System.Diagnostics.DebuggerNonUserCode]
    [global::System.Runtime.CompilerServices.CompilerGenerated]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public readonly partial struct WorkDoneDomainEvent : global::Minerals.AutoDomain.IDomainEvent, global::System.IEquatable<WorkDoneDomainEvent>
    {
        public int Arg1 { get; }
        public int Arg2 { get; }
        public int Arg3 { get; }

        public WorkDoneDomainEvent(int arg1, int arg2, int arg3)
        {
            Arg1 = arg1;
            Arg2 = arg2;
            Arg3 = arg3;
        }

        public bool Equals(WorkDoneDomainEvent other)
        {
            return other.Arg1.Equals(Arg1) && other.Arg2.Equals(Arg2) && other.Arg3.Equals(Arg3);
        }

        public override bool Equals(object obj)
        {
            return obj is WorkDoneDomainEvent other && other.Arg1.Equals(Arg1) && other.Arg2.Equals(Arg2) && other.Arg3.Equals(Arg3);
        }

        public override int GetHashCode()
        {
            return global::System.HashCode.Combine(Arg1, Arg2, Arg3);
        }

        public static bool operator ==(WorkDoneDomainEvent left, WorkDoneDomainEvent right)
        {
            return left.Arg1.Equals(right.Arg1) && left.Arg2.Equals(right.Arg2) && left.Arg3.Equals(right.Arg3);
        }

        public static bool operator !=(WorkDoneDomainEvent left, WorkDoneDomainEvent right)
        {
            return !left.Arg1.Equals(right.Arg1) || !left.Arg2.Equals(right.Arg2) || !left.Arg3.Equals(right.Arg3);
        }
    }
}
```

## Versioning

We use [SemVer](http://semver.org/) for versioning. For the versions available, see the [branches on this repository](https://github.com/SzymonHalucha/Minerals.AutoDomain/branches).

## Authors

- **Szymon Ha≈Çucha** - Maintainer

See also the list of [contributors](https://github.com/SzymonHalucha/Minerals.AutoDomain/contributors) who participated in this project.

## License

This project is licensed under the MIT License - see the [LICENSE](./LICENSE) file for details.
